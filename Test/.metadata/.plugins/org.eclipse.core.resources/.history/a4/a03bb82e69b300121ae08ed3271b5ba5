import java.net.DatagramPacket;
import java.util.HashSet;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;



public class SenderRecoveryListener implements Runnable {

	private Thread t = null;
	private volatile HashSet<Integer> hs = null;
	private SocketManager sm = null;
	private FileSeperator fs = null;

	private final int poolSize = 4; //Resend 4
	private final ExecutorService resendTaskPool;


	//For Sender Recovery Listener
	public SenderRecoveryListener(SocketManager socket, FileSeperator seperator, int unused)
	{
		fs = seperator;
		sm = socket;
		hs = new HashSet<Integer>();
		resendTaskPool = Executors.newFixedThreadPool(poolSize);

		t = new Thread(this);
		t.setDaemon(true);
		t.start();

	}

	//For Receiver Recovery Listener
	public SenderRecoveryListener(SocketManager socket, FileSeperator seperator)
	{
		fs = seperator;
		sm = socket;
		hs = new HashSet<Integer>();
		resendTaskPool = Executors.newFixedThreadPool(poolSize);

	}



	protected void finalize()
	{
		resendTaskPool.shutdownNow();
	}

	@Override
	public void run() {
		while(true)
		{
			DatagramPacket pack = sm.recievePacket();
			int seqN = SocketManager.getPacketSeqNum(pack);
			System.out.println("Listener Received Packet SeqN: "+ seqN);

			if(seqN>0){
				if(hsContains(seqN))
					hsRemove(seqN);

			}
			else if(seqN < 0){

				
				seqN = Math.abs(seqN);

				//if Have not start a resend packet task
				if(!hsContains(seqN))
				{
					hsAdd(seqN);
					resendTaskPool.execute(new ResendPacketTask(sm, fs, seqN, 0L));

				}			
			}
		}
	}

	public synchronized boolean hsContains(int seq)
	{
		return hs.contains(seq);
	}

	public synchronized boolean hsAdd(int seq)
	{
		return hs.add(seq);
	}

	public synchronized boolean hsRemove(int seq)
	{
		return hs.remove(seq);
	}




	class ResendPacketTask implements Runnable{

		Thread t = null;
		int seqN = 0;
		SocketManager sm = null;
		FileSeperator fs = null;
		long randomTimeElapse = 0;

		public ResendPacketTask(SocketManager socket, FileSeperator seperator, int seqNum, long timeElapse)
		{
			sm = socket;
			fs = seperator;
			seqN = seqNum;
			randomTimeElapse = timeElapse;
		}


		@Override
		public void run() {

			Random r = new Random();
			
			
			//Random Backoff
			try {
				if(randomTimeElapse <= 0)
				{
					int timer = r.nextInt(100);
					TimeUnit.MILLISECONDS.sleep(timer+10);
				}else
				{
					//Have not implemented yet
					//random timer setting
				}
				//				else
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				System.err.println("ResendPacketTask Thread for SeqNum: "+ seqN +" got interrupted!");
				e.printStackTrace();
			}

			if(hsContains(seqN))
			{
				hsRemove(seqN);
				byte[] buf = fs.getDataBlock(seqN);
				sm.sendStdPacket(seqN, buf);

				System.out.println("Send Recovery DataPacket SeqN: " + seqN);
			}
		}
	}

	/**
	 * @param args
	 */	
	public static void main(String[] args) {
		FileSeperator fs = new FileSeperator("/Users/Freehan/Desktop/Test/Test");
		fs.getFileAttribute();
		fs.printFileAttribute();
		SocketManager Sender = new SocketManager();
//		ExecutorService listener = Executors.newSingleThreadExecutor();
//		listener.execute(new SenderRecoveryListener(Sender, fs, 0));
//		try {
//			TimeUnit.SECONDS.sleep(1);	
//			listener.shutdownNow();
//		} catch (InterruptedException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		
		SenderRecoveryListener srl = new SenderRecoveryListener(Sender, fs, 0);
		
		
		try {
			TimeUnit.SECONDS.sleep(10);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}	
		srl.finalize();
		
	}


}
